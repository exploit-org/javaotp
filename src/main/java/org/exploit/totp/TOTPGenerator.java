package org.exploit.totp;

import org.bouncycastle.util.encoders.Base32;
import org.exploit.totp.config.TOTPConfig;
import org.exploit.totp.exception.OTPCreateException;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.time.Instant;

public class TOTPGenerator {
    private final TOTPConfig config;

    public TOTPGenerator(TOTPConfig config) {
        this.config = config;
    }

    public String generateSecret() {
        var buffer = new byte[config.getSecretLength()];
        RANDOM.nextBytes(buffer);

        return new String(Base32.encode(buffer));
    }

    public String generate(String secret) {
        var epochSeconds = Instant.now().getEpochSecond();
        var timeStep = epochSeconds / config.getTimeStepSeconds();

        return create(secret, timeStep);
    }

    public boolean verify(String secret, String userCode) {
        return generate(secret).equals(userCode);
    }

    public String createQrPayload(String account, String issuer, String secret) {
        var encodedAccount = URLEncoder.encode(account, StandardCharsets.UTF_8);
        var encodedIssuer = URLEncoder.encode(issuer, StandardCharsets.UTF_8);

        return String.format(URI_FORMAT, encodedIssuer, encodedAccount,
                secret, encodedIssuer,
                config.getAlgorithm().name(),
                config.getOtpLength(),
                config.getTimeStepSeconds()
        );
    }

    private String create(String key, long time) {
        var data = timeToBytes(time);
        var hash = hash(data, key);

        var offset = hash[hash.length - 1] & 0xF;
        var truncatedHash = extractPartOfHash(hash, offset);

        truncatedHash &= 0x7FFFFFFF;
        truncatedHash %= (long) Math.pow(10, config.getOtpLength());

        return String.format("%0" + config.getOtpLength() + "d", truncatedHash);
    }

    private byte[] timeToBytes(long time) {
        var data = new byte[8];

        for (var i = 8; i-- > 0; time >>>= 8)
            data[i] = (byte) time;

        return data;
    }

    private byte[] hash(byte[] data, String key) {
        var secretKeyBytes = Base32.decode(key);

        var macAlgorithm = config.getAlgorithm().getMacAlgorithm();
        var signKey = new SecretKeySpec(secretKeyBytes, macAlgorithm);

        try {
            var mac = Mac.getInstance(macAlgorithm);
            mac.init(signKey);

            return mac.doFinal(data);
        } catch (NoSuchAlgorithmException | InvalidKeyException e) {
            throw new OTPCreateException(e);
        }
    }

    private long extractPartOfHash(byte[] hash, int offset) {
        var truncatedHash = 0L;

        for (var i = 0; i < 4; ++i) {
            truncatedHash <<= 8;
            truncatedHash |= (hash[offset + i] & 0xFF);
        }

        return truncatedHash;
    }

    private static final SecureRandom RANDOM = new SecureRandom();

    private static final String URI_FORMAT = "otpauth://totp/%s:%s?secret=%s&issuer=%s&algorithm=%s&digits=%d&period=%d";
}
